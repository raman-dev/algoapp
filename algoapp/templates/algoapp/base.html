<!DOCTYPE html class="h-100">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta http-equiv="Content-Language" content="en">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    
    <script src="https://d3js.org/d3.v5.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
    
    <script type="text/javascript">

        function Point(x,y){
            this.x = x;
            this.y = y;
        }

        Point.prototype.toString = function() {
            return "n"+this.x.toString()+""+this.y.toString();
        };

        function shuffle(a) {
            var j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(Math.random() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        }
        
            //return n random points in the plane of width x height
        function getRandomPointSet(width,height,radius,n){
                //return a point set of within width x height
                //where each point has radius,'radius', 
                //points must be non overlapping 
                //divide the plane into radius x radius squares
                //width / radius => num squares in width
                //height / radius => num squares in height
                //randomly select indices from 0 to 
                var h = height - radius;
                var w = width - radius;
                var rows = Math.floor(h / (radius*2));
                var cols = Math.floor(w / (radius*2));
                //randomly select rows and cols
                //select n pairs from rows and cols
                
                console.log(rows);
                console.log(cols);
                var r_index = [];
                var c_index = [];
                for(i = 1; i < rows - 1;i++){
                    r_index.push(i);
                }
                for(i = 1;i < cols - 1;i++){
                    c_index.push(i);
                }
                //n rows and n cols
                shuffle(r_index);
                shuffle(c_index);
                //console.log(r_index);
                //console.log(c_index);
                //
                let points = [];
                for(i = 0 ;i < n;i++){
                    points.push(new Point(c_index[i],r_index[i]));
                }
                return points;
            }
            
        function drawLines(points,scale){
            var svg = d3.select("svg");
            let parray = [];
            for (i = 0;i < points.length;i++){
                let a = [points[i].x*(2*scale),points[i].y*(2 * scale)];
                parray.push(a);
            }
            var lines = svg.selectAll("path");
            lgen = d3.line();
            lines.attr("d",lgen(parray));
        }

        function drawNodes(points,radius,fill_color){
            points.sort((a,b)=>{
                //less than 0 means b is larger
                //0 means equal
                //greater than 0 means a is the larger
                return  a.x - b.x;
            });
            var svg = d3.select("svg");//svg to draw nodes on
            var nodes = svg.selectAll("circle");
            //set position and radius
            var num_nodes = nodes.size();
            var anim_duration = 750;
            //work on all nodes available
            nodes = nodes.data(points);
            nodes.transition()
            .duration(anim_duration)
            .attr("r",(d,i) => {return radius})
            .style("fill",fill_color)
            .attr("stroke","black")
            .attr("stroke-width","0.25%")
            .attr("id",(d,i) => {return d.toString();} )
            .attr("cx", (p) => { return p.x*(2 * radius)})
            .attr("cy", (p) => { return p.y*(2 * radius)});
            //nodes.style("fill","black").transition()

            //not enough nodes already on the screen
            if (num_nodes < points.length){
                //we need to add nodes
                //this count doesn't matter since 1 call will sync it if we provide data
                //nodes_add = points.length - nodes.size();
                ////enter represents the selection of new circles
                //nodes = svg.selectAll("circle");
                nodes = nodes.enter().append('circle');
                nodes.transition().duration(anim_duration)
                .attr("r",radius)
                .style("fill",fill_color)
                .attr("stroke","black")
                .attr("stroke-width","0.25%")
                .attr("id",(d,i) => {return d.toString();} )
                .attr("cx", (p) => { return p.x*(2 * radius)})
                .attr("cy", (p) => { return p.y*(2 * radius)});
            }else if(num_nodes > points.length){
                //remove this many nodes
                //nodes_remove = nodes.size() - points.length;
                nodes.exit().transition()
                .duration(anim_duration)
                .attr('r',0)
                .remove();
            }
            //enough nodes just pass in new data and radius
        }
        const hull_hlight = "blue";
        const uhull_hlight = "red";
        const lhull_hlight = "green";
        const neutral_hlight= "black";

        function quickhull(points){
            //given all these points
            //perform quick hull
            //first sort points by x coordinate
            points.sort((a,b)=>{
                //less than 0 means b is larger
                //0 means equal
                //greater than 0 means a is the larger
                return  a.x - b.x;
            });
            console.log(points);
            //now find the two most extreme points from the set
            pmin = points[0];
            pmax = points[points.length - 1];
            highlightNode(pmin,neutral_hlight,hull_hlight);
            highlightNode(pmax,neutral_hlight,hull_hlight);
            //now we need to highlight each point
            console.log(pmin);
            console.log(pmax);
            //seperate into upperhull and lowerhull
            //
            var upperhull = [];
            var lowerhull = [];
            //for every point inbetween min index and max index\
            //don't include end points in the new intervals
            var pmu = null;
            var pml = null;

            var upper_max_area = 0;
            var lower_max_area = 0;

            points.forEach( p => {
                if(p != pmin && p != pmax){
                    var d = determinant(pmax,p,pmin);
                    if(d < 0){
                        upperhull.push(p);
                        //calculate the area of the trianlge constructed by
                        //conveniently half the determinant is also the area of the triangle constructed by those 3 poiints 
                        if(-d / 2 > upper_max_area){
                            upper_max_area = -d/2;
                            pmu = p;
                        }
                    }else{
                        lowerhull.push(p);
                        if(d/2 > lower_max_area){
                            lower_max_area = d/2;
                            pml = p;
                        }
                    }
                }
            });

            console.log(upperhull);
            console.log(lowerhull);
            //if the upperhull is non empty
            console.log(pmu);
            console.log(pml);
            highlightNode(pmu,neutral_hlight,uhull_hlight);//so redraw a node there? or alter that node
            highlightNode(pml,neutral_hlight,lhull_hlight);
            //find pmax upper
            //this point will maximize the area of triangle pminpmupmax
            //finding this will encompass points within the triangle
            //and using the determinant we can then find points we need to quick hul
            //that are to the left of pminpmu and right of pmupmax
            //the triangle that
            //how to find pmax upper
            //now if pmu == null means upper hull is empty
            //if pml == null means lower hull is empty

        }

        function determinant(p1,p2,p3){
            return p1.x*p2.y + p2.x*p3.y + p3.x*p1.y -p1.y*p2.x - p2.y*p3.x - p3.y*p1.x;
        }

        function highlightNode(point,stroke_color,fill_color){
            //highlight this particular node in the svg
            //maybe i can keep an index map of which point corresponds to what index
            d3.select("svg")
            .select("#"+point.toString()).transition().duration(700)
            .attr("stroke",stroke_color)
            .style("fill",fill_color);
        }

        function updateLabels(algo_id){
            switch (id){
                case "dijkstras":
                    $(".carousel").carousel(0);

                    break;
                case "quickhull":
                    $(".carousel").carousel(1);

                    break;
                case "johnson_trotter":
                    $(".carousel").carousel(2);
                    break;
            }
        }
        $(document).ready(function() { 
            $(".dropdown-item").on('click',function(e){
                id = $(this).attr('id');
                console.log(id);
                $("a.active").removeClass("active");
                $("#"+id).addClass("active");
                $(".dropdown-menu").removeClass("show");

                //rotate a carousel?
                //or what
                //clear canvas
                //change the title
                updateLabels(id);
                readyDrawSVG(id);
            });
            readyDrawSVG("quickhull");
        });
        const MIN_D_NODES = 5;//nodes
        const MIN_Q_NODES = 20;//points
        
        const D_NODE_RADIUS = 20;
        const Q_NODE_RADIUS = 5;
        
        const width = 720;
        const height = 480;

        function readyDrawSVG(id){
            switch (id){
                case "dijkstras":
                    //clear svg 
                    //then call drawNodes with min default nodes
                    drawNodes(getRandomPointSet(width,height,D_NODE_RADIUS,MIN_D_NODES)
                    ,D_NODE_RADIUS
                    ,"white");//requires points
                    break;
                case "quickhull":
                    //clear svg
                    //call drawNodes with min default nodes
                    drawNodes(getRandomPointSet(width,height,Q_NODE_RADIUS,MIN_Q_NODES)
                    ,Q_NODE_RADIUS,//radius
                    "white");//fill color
                    break;
            }
        }
    </script>
    <title>Algo Demo</title>
  </head>
  <body>
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <a class="navbar-brand">
                AlgoApp
            </a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav mr-auto" >
                    <li class="nav-item">
                        <div class ="dropdown" >
                            <button id="algoDropDown" class="rounded-0 btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                Algorithms
                            </button>
                            <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                                <a href="#" id="dijkstras" class="dropdown-item" >DIJKSTRAS</a>          
                                <a href="#" id="quickhull" class="dropdown-item active" >QUICKHULL</a>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
        </nav>

    <div class="container-fluid h-100">
        <div class="row">
            <div class="col-4">
                <!--
                    describe algorithm
                -->

                <div class="carousel slide" data-ride="false" data-interval="false">
                    <div class="carousel-inner">
                        <div class="carousel-item">
                            <h1>
                                DIJKSTRAS
                            </h1>
                            <p >
                                Shortest Single Source Path
                            </p>
                            <p >
                                Find the shortest single source path in a weighted connected graph.
                                Result of algorithm is always an edge set that describes the shortest paths form some source.
                            </p>
                            <p>
                                <b>Solution:</b>
                            </p>
                            <p>
                                Starting at some source vertex v, select an edge that has the smallest path length from source to v*.
                                Select the next edge that has minimum path length from the source to some vertex not connected in the edge set.
                                Repeat the process until the edge set contains connections to all vertices.
                            </p>
                        </div>
                        <div class="carousel-item active">
                            <h1>
                                QUICKHULL
                            </h1>
                            <p >
                                Convex Hull Problem
                            </p>
                            <p >
                                Find the convex hull of a set of points on the cartesian plane.
                            </p>
                            <p>
                                <b>Solution:</b>
                            </p>
                            <p >
                                Given a set of points S ={p1, p2,.., pn} on the cartesian plane. Sort the set by increasing x coordinate, breaking ties using the larger y coordinate. The leftmost point, p1 and right most point pn of the set are part of the convex hull. The divide the set using the line p1pn into two smaller sets, one left of the line and one right of the line. The two sets are called the upper hull and the lower hull, the process must be repeated for each set, joining the sets will complete the convex hull.
                            </p>
                        </div>
                    </div>
                </div>
                
            </div>
           
            <div class="col-8" >
                {% block content %}
                {% endblock %}
            </div>
        </div>
    </div>
    
  </body>
</html>