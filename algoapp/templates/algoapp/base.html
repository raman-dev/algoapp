<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
    <!-- Google Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
    <!-- Bootstrap core CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css" rel="stylesheet">
    <!-- Material Design Bootstrap -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" rel="stylesheet">

    <!-- JQuery -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <!-- Bootstrap tooltips -->
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/umd/popper.min.js"></script>
    <!-- Bootstrap core JavaScript -->
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/js/bootstrap.min.js"></script>
    <!-- MDB core JavaScript -->
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js"></script>
    <script src="https://d3js.org/d3.v5.js"></script>
    <script src="https://unpkg.com/d3-interpolate-path/build/d3-interpolate-path.min.js"></script>


    <script type="text/javascript">
        const MIN_Q_NODES = 20;//points
        const DEFAULT_PERM = "abc";//default text for permutation

        const Q_NODE_RADIUS = 5;

        const width = 720;
        const height = 480;

        const blue = "blue";
        const red = "red";
        const green = "green";
        const cyan = "#0bb";

        var scale = 2 * Q_NODE_RADIUS;
        var hull_points = null;
        var quicksort = null;


        function Point(x, y) {
            this.x = x;
            this.y = y;
        }

        Point.prototype.toString = function () {
            return "n" + this.x.toString() + "" + this.y.toString();
        };

        class AnimationNode {
            id = null;
            points = null;

            constructor(id, points) {
                this.points = points;
                this.id = id;
                if (points.length == 3) {
                    this.local_d1 = [[points[0].x * scale, points[0].y * scale], [points[2].x * scale, points[2].y * scale]];
                    this.local_d2 = Array.from(this.local_d1);
                    this.local_d2.splice(1, 0, [points[1].x * scale, points[1].y * scale]);
                }
            }

            renderLines(next_index, animNodes) {
                //now what?
                //now if points is size 2 do a transition from a to b
                //if size is 3 then do a transition from points[0],points[2] to points[0],points[1],points[2]
                if (this.points.length == 2) {
                    var pmin = this.points[0];
                    var pmax = this.points[1];
                    highlightNode(pmin, cyan, blue).on('end', () => {
                        highlightNode(pmax, cyan, blue).on('end', () => {
                            drawHullLine([[pmin.x * scale, pmin.y * scale]], this.id, scale, cyan);
                            transitionLine(this.id, [[pmin.x * scale, pmin.y * scale]], [[pmin.x * scale, pmin.y * scale], [pmax.x * scale, pmax.y * scale]]).on('end', () => {
                                if (next_index < animNodes.length) {
                                    animNodes[next_index].renderLines(next_index + 1, animNodes);
                                }
                            });
                        });
                    });


                } else {
                    //we want to highlight the middle point
                    highlightNode(this.points[1], cyan, blue).on('end', () => {
                        drawHullLine(this.local_d1, this.id, scale, cyan);
                        transitionLine(this.id, this.local_d1, this.local_d2).on('end', () => {
                            if (next_index < animNodes.length) {
                                animNodes[next_index].renderLines(next_index + 1, animNodes);
                            }
                        });
                    });

                }
            }
        }

        function shuffle(a) {
            var j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(Math.random() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        }

        //return n random points in the plane of width x height
        function getRandomPointSet(width, height, radius, n) {
            //return a point set of within width x height
            //where each point has radius,'radius', 
            //points must be non overlapping 
            //divide the plane into radius x radius squares
            //width / radius => num squares in width
            //height / radius => num squares in height
            //randomly select indices from 0 to 
            var h = height - radius;
            var w = width - radius;
            var rows = Math.floor(h / (radius * 2));
            var cols = Math.floor(w / (radius * 2));
            //randomly select rows and cols
            //select n pairs from rows and cols

            var r_index = [];
            var c_index = [];
            for (i = 1; i < rows - 1; i++) {
                r_index.push(i);
            }
            for (i = 1; i < cols - 1; i++) {
                c_index.push(i);
            }
            //n rows and n cols
            shuffle(r_index);
            shuffle(c_index);
            let points = [];
            for (i = 0; i < n; i++) {
                points.push(new Point(c_index[i], r_index[i]));
            }
            return points;
        }

        function drawNodes(points, radius, node_scale, fill_color, label_flag) {
            points.sort((a, b) => {
                //less than 0 means b is larger
                //0 means equal
                //greater than 0 means a is the larger
                return a.x - b.x;
            });
            var svg = d3.select("svg");//svg to draw nodes on
            var nodes = svg.selectAll("circle");
            //set position and radius
            var num_nodes = nodes.size();
            var anim_duration = 750;
            //work on all nodes available
            nodes = nodes.data(points);
            nodes.transition()
                .duration(anim_duration)
                .attr("r", (d, i) => { return radius })
                .style("fill", fill_color)
                .attr("stroke", "black")
                .attr("stroke-width", "0.25%")
                .attr("id", (d, i) => { return d.toString(); })
                .attr("cx", (p) => { return p.x * (node_scale) })
                .attr("cy", (p) => { return p.y * (node_scale) });
            //nodes.style("fill","black").transition()

            //not enough nodes already on the screen
            if (num_nodes < points.length) {
                //we need to add nodes
                //this count doesn't matter since 1 call will sync it if we provide data
                //nodes_add = points.length - nodes.size();
                ////enter represents the selection of new circles
                //nodes = svg.selectAll("circle");
                nodes = nodes.enter().append('circle');
                nodes.attr("cx", width / 2);
                nodes.attr("cy", height / 2);
                nodes.transition().duration(anim_duration)
                    .attr("r", radius)
                    .style("fill", fill_color)
                    .attr("stroke", "black")
                    .attr("stroke-width", "0.25%")
                    .attr("id", (d, i) => { return d.toString(); })
                    .attr("cx", (p) => { return p.x * node_scale })
                    .attr("cy", (p) => { return p.y * node_scale });
            } else if (num_nodes > points.length) {
                //remove this many nodes
                //nodes_remove = nodes.size() - points.length;
                nodes.exit().transition()
                    .duration(anim_duration)
                    .attr('r', 0)
                    .remove();
            }
            //enough nodes just pass in new data and radius`
            if (label_flag == true) {
                var text = svg.selectAll("text")
                    .data(points)
                    .enter()
                    .append("text");

                text.attr("x", (d) => { return d.x * scale; })
                    .attr("y", (d) => { return d.y * scale; })
                    .attr("id", (d) => { return d.toString(); })
                    .text((d) => { return "(" + d.x + "," + d.y + ")"; })
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("fill", "black");
            }
        }

        function convex_hull(data) {
            data.sort((a, b) => {
                return a.x - b.x;
            });
            var result = [];
            var animNodes = [];
            quickhull(data, result, animNodes);
            //highlight nodes as they are selected
            //so first highlight blue pmin and pmax
            //result.forEach( p => { highlightNode(p,cyan,blue);});
            animNodes[0].renderLines(1, animNodes);
        }

        function determinant(p1, p2, p3) {
            return p1.x * p2.y + p2.x * p3.y + p3.x * p1.y - (p1.y * p2.x) - (p2.y * p3.x) - (p1.x * p3.y);
        }

        function quickhull(points, result, animNodes) {
            var pmin = points[0];
            var pmax = points[points.length - 1];

            if (result.length == 0) {
                result.push(pmin);
                result.push(pmax);
                minmax_id = pmin.toString() + pmax.toString();
                animNodes.push(new AnimationNode(minmax_id, [pmin, pmax]));
            }
            var upperhull = [];
            var lowerhull = [];

            var pmax_upper;
            var pmax_lower;

            var upper_max_area = 0;
            var lower_max_area = 0;

            points.forEach(p => {
                if (p != pmin && p != pmax) {
                    var d = determinant(pmin, pmax, p);
                    if (d > 0) {
                        upperhull.push(p);
                        if (d / 2 > upper_max_area) {
                            upper_max_area = d / 2;
                            pmax_upper = p;
                        }
                    } else {
                        lowerhull.push(p);
                        if (d / 2 < lower_max_area) {
                            lower_max_area = d / 2;
                            pmax_lower = p;
                        }
                    }
                }
            });

            if (lowerhull.length > 0) {
                result.push(pmax_lower);
                var id = pmin.toString() + pmax_lower.toString() + pmax.toString();
                animNodes.push(new AnimationNode(id, [pmin, pmax_lower, pmax]));

                //points to the left of the pmin pmaxupper line
                var left_lower_hull = [pmin];
                //points to the left of the pmaxupper-pmax line
                var right_lower_hull = [pmax_lower];
                lowerhull.forEach(p => {
                    //left_upper potential
                    if (p != pmax_lower) {
                        if (p.x < pmax_lower.x) {
                            var d = determinant(pmin, pmax_lower, p);
                            if (d < 0) {
                                left_lower_hull.push(p);
                            }
                        } else {
                            var d = determinant(pmax_lower, pmax, p);
                            if (d < 0) {
                                right_lower_hull.push(p);
                            }
                        }
                    }

                });
                left_lower_hull.push(pmax_lower);
                right_lower_hull.push(pmax);
                if (left_lower_hull.length > 2) {
                    quickhull(left_lower_hull, result, animNodes);
                }
                if (right_lower_hull.length > 2) {
                    quickhull(right_lower_hull, result, animNodes);
                }
            }
            if (upperhull.length > 0) {
                result.push(pmax_upper);
                var id = pmin.toString() + pmax_upper.toString() + pmax.toString();
                animNodes.push(new AnimationNode(id, [pmin, pmax_upper, pmax]));
                //points to the left of the pmin pmaxupper line
                var left_upper_hull = [pmin];
                //points to the left of the pmaxupper-pmax line
                var right_upper_hull = [pmax_upper];
                upperhull.forEach(p => {
                    //left_upper potential
                    if (p != pmax_upper) {
                        if (p.x < pmax_upper.x) {
                            var d = determinant(pmin, pmax_upper, p);
                            if (d > 0) {
                                left_upper_hull.push(p);
                            }
                        } else {
                            var d = determinant(pmax_upper, pmax, p);
                            if (d > 0) {
                                right_upper_hull.push(p);
                            }
                        }
                    }

                });
                left_upper_hull.push(pmax_upper);
                right_upper_hull.push(pmax);
                if (left_upper_hull.length > 2) {
                    quickhull(left_upper_hull, result, animNodes);
                }
                if (right_upper_hull.length > 2) {
                    quickhull(right_upper_hull, result, animNodes);
                }
            }
        }

        function transitionLine(id, d1, d2) {
            var line = d3.line();
            var t = d3.select("#" + id).attr('d', line(d1)).transition();
            return t.duration(500).attrTween('d', function () { return d3.interpolatePath(line(d1), line(d2)); });
        }

        function drawHullLine(points, id, scale, stroke_color) {
            var svg = d3.select("svg");
            var path = svg.append("path");
            var data = points;
            //points.forEach( p=> {data.push([p.x*scale,p.y*scale]);});
            var line = d3.line(data);
            path.attr('d', line(data));
            path.attr('fill', "none");
            path.attr('id', id);
            path.attr('class', 'hull_line');
            path.attr('stroke', stroke_color);
            return path;
        }

        function highlightNode(point, stroke_color, fill_color) {
            //highlight this particular node in the svg
            //maybe i can keep an index map of which point corresponds to what index
            if (point == null) {
                return;
            }
            return d3.select("svg")
                .select("#" + point.toString()).transition().duration(300)
                .attr("stroke", stroke_color)
                .style("fill", fill_color);
        }

        function updateCarousel(algo_id) {
            switch (id) {
                case "quickhull":
                    $(".carousel").carousel(0);
                    break;
                case "johnson_trotter":
                    $(".carousel").carousel(1);
                    break;
                case "quicksort":
                    $(".carousel").carousel(2);
                    break;
            }
        }
        $(document).ready(function () {
            $('#permutation_input').on('input', () => {
                updateSVGText($('#permutation_input').val());
            });
            $(".nav-item").on('click', function (e) {
                id = $(this).attr('id');
                //$("a.active").removeClass("active");
                previous_id = $('li.active').attr('id');
                if (id == previous_id) {
                    return;
                }
                $("li.active").removeClass("active");
                $("#" + id).addClass("active");

                //rotate a carousel?
                //or what
                //clear canvas
                //change the title
                updateCarousel(id);
                readyDrawSVG(id, previous_id);
            });
            readyDrawSVG("quickhull");
        });


        function clearHullLines() {
            d3.selectAll(".hull_line").transition().attr("stroke", "white").on('end', () => {
                d3.selectAll(".hull_line").remove();
            });
        }
        var permString = null;
        function readyDrawSVG(id, previous_id) {
            if (previous_id == 'johnson_trotter') {
                permString.fadeOut();
            } else if (previous_id == 'quicksort') {
                quicksort.fadeOut();
            }
            switch (id) {
                case "quickhull":
                    //clear svg
                    //call drawNodes with min default nodes
                    clearHullLines();
                    if (hull_points == null) {
                        hull_points = getRandomPointSet(width, height, Q_NODE_RADIUS, MIN_Q_NODES)
                    }
                    drawNodes(hull_points, Q_NODE_RADIUS, 2 * Q_NODE_RADIUS, "white", false);//fill color
                    break;
                case "johnson_trotter":
                    //do what 
                    clearCircles();
                    clearHullLines();
                    //now what?
                    //now nothing
                    if (permString == null) {
                        permString = new PermutationString(width, height);
                    }
                    permString.fadeIn();
                    //show arrows above all text
                    //initially all text has left arrows
                    //we will flip arrows     
                    break;
                case "quicksort":
                    clearCircles();
                    clearHullLines();
                    if (quicksort == null) {
                        quicksort = new QuickSort(width, height);
                    }
                    quicksort.shuffle();
                    quicksort.fadeIn();
                    break;
            }
        }

        class QuickSort {
            array = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            initial_x = null;
            center_y = null;

            left_iter = null;
            right_iter = null;
            pivot = null;

            duration = 500;

            shuffle() {
                shuffle(this.array);
                console.log(this.array);
            }

            getArrayString() {
                var result = '';
                for (i = 0; i < this.array.length; i++) {
                    result += this.array[i];
                }
                return result;
            }

            constructor(width, height) {
                //shuffle(this.array);
                //add the qs_text elements
                var text = d3.select('svg').selectAll('.qs_text')
                    .data(this.array)
                    .enter()
                    .append('text');

                this.initial_x = width / 2 - (this.array.length / 2) * 30;
                this.center_y = height / 2 - 18;
                text.attr('x', (d, i) => {
                    return this.initial_x + i * 30;
                })
                    .attr('y', this.center_y + '')
                    .attr('class', 'qs_text')
                    .attr('font-family', 'sans-serif')
                    .attr('font-size', '32px')
                    .attr('fill', 'black')
                    .attr('id', (d, i) => {
                        return 'qs' + i;
                    });
                d3.select('svg')
                    .selectAll('.qs_iters')
                    .attr('x', this.initial_x + '')
                    .attr('y', (this.center_y - 36) + '')
                    .attr('font-family', 'sans-serif')
                    .attr('font-size', '0px')
                    .attr('fill', 'white');
                var svg = d3.select('svg');
                svg.select('#qs_pivot').attr('y', (this.center_y + 36) + '');
                svg.select('#qs_lbar').attr('y', (this.center_y + 36) + '');
                svg.select('#qs_rbar').attr('y', (this.center_y + 36) + '');

            }

            sort(action_list, index) {
                //just call transition and change positions
                //for each action
                //keep grabbing actions
                var obj = action_list[index];
                var key = Object.keys(action_list[index])[0];
                console.log(key);
                switch (key) {
                    case 'SWAP':
                        //if we swap action
                        //we swap the values at
                        //this is a swap between the pivot index and the value at left or right iter
                        console.log(obj);
                        var index_a = obj['SWAP'][0];
                        var index_b = obj['SWAP'][1];

                        var t = this.array[index_a];
                        this.array[index_a] = this.array[index_b];
                        this.array[index_b] = t;
                        //so swap the order in array
                        console.log(index_a);
                        console.log(index_b);
                        //now swap the elements at index_a and index_b
                        d3.select('svg').select('#qs' + index_a).transition().duration(this.duration)
                            .attr('x', '' + (this.initial_x + index_b * 30));
                        d3.select('svg').select('#qs' + index_b).transition().duration(this.duration)
                            .attr('x', '' + (this.initial_x + index_a * 30))
                            .on('end', () => {
                                //swap the two id's
                                d3.select('svg').select('#qs' + index_b).attr('id', 'qstemp');
                                d3.select('svg').select('#qs' + index_a).attr('id', 'qs' + index_b);
                                d3.select('svg').select('#qstemp').attr('id', 'qs' + index_a);
                                if (index != action_list.length - 1) {
                                    this.sort(action_list, index + 1);
                                }
                            });
                        break;
                    case 'LI_MOVE':
                        //
                        this.left_iter = obj['LI_MOVE'];
                        d3.select('svg').selectAll('#qs_liter').transition().duration(this.duration)
                            .attr('x', '' + (this.initial_x + this.left_iter * 30))
                            .on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.sort(action_list, index + 1);
                                }
                            });
                        break;
                    case 'RI_MOVE':
                        this.right_iter = obj['RI_MOVE'];
                        d3.select('svg').selectAll('#qs_riter').transition().duration(this.duration)
                            .attr('x', '' + (this.initial_x + this.right_iter * 30))
                            .on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.sort(action_list, index + 1);
                                }
                            });
                        break;
                    case 'P_MOVE':
                        this.pivot = obj['P_MOVE'];
                        d3.select('svg').selectAll('#qs_pivot').transition().duration(this.duration)
                            .attr('x', '' + (this.initial_x + this.pivot * 30))
                            .on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.sort(action_list, index + 1);
                                }
                            });
                        break;
                    case 'NEW_PARTITION':
                        //put 2 partition bars showing the new parition
                        var lbar_index = obj['NEW_PARTITION'][0];
                        var rbar_index = obj['NEW_PARTITION'][1];

                        d3.select('svg').selectAll('#qs_lbar').transition().duration(this.duration)
                            .attr('x', '' + ((this.initial_x + lbar_index * 30) - 9));
                        d3.select('svg').selectAll('#qs_rbar').transition().duration(this.duration)
                            .attr('x', '' + (18 + this.initial_x + rbar_index * 30))
                            .on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.sort(action_list, index + 1);
                                }
                            });
                        break;
                }
            }

            fadeIn() {
                for (i = 0; i < this.array.length; i++) {
                    d3.select('svg').select('#qs' + i).attr('x', '' + (this.initial_x + i * 30))
                        .text('' + this.array[i]);
                }
                d3.select('svg').selectAll('.qs_text')
                    .transition()
                    .attr('fill', 'black')
                    .attr('font-size', '32px');
                d3.select('svg').selectAll('.qs_iters')
                    .transition().attr('fill', 'black').attr('font-size', '32px');
            }

            fadeOut() {
                var svg = d3.select('svg').selectAll('.qs_text');
                svg.transition()
                    .attr('fill', 'white')
                    .attr('font-size', '0px');
                d3.select('svg').selectAll('.qs_iters')
                    .transition().attr('fill', 'white').attr('font-size', '0px');

            }
        }
        //what object can i create?
        //so each letter has a direction so when we call draw()
        //the letter should appear
        class PermutationString {

            num_letters = 4;//minimum letters in a string
            font_size = 32;
            char_space = 0;//width of a single text element
            center_x = 0;
            center_y = 0;

            data = [];
            y_position = null;
            initial_x = null;
            chevron_ypos = null;
            duration = 500;

            directionTransitionMap = null;

            isAnimating = false;
            constructor(width, height) {
                this.center_x = width / 2;
                this.y_position = height / 2;
                this.directionTransitionMap = new Map();
                //create minimum 4 text elements in svg
                //this. data = d3.range(0,this.num_letters);
                for (i = 0; i < this.num_letters; i++) {
                    this.data.push("" + i);
                }

                var svg = d3.selectAll("svg");
                var text = svg.selectAll(".perm_text")
                    .data(this.data)
                    .enter()
                    .append("text");

                this.initial_x = this.center_x - 2 * (30);//how many characters are there? 4
                this.chevron_ypos = this.y_position - 60;
                text.attr("x", (d, i) => {
                    return '' + (this.initial_x + i * 30);
                })//center in x direction
                    .attr("y", (d) => { return this.y_position; })//center in y direction
                    .attr("id", (d) => { return "t" + d.toString(); })
                    .text((d, i) => { return i + ""; }) //default text is index of each element
                    .attr("font-family", "sans-serif")
                    .attr('class', 'perm_text')
                    .attr("font-size", this.font_size + "px")
                    .attr("fill", "black");
                //position the 
                d3.select('svg')
                    .selectAll('g')
                    .attr('transform', (d, i) => {
                        return 'translate(' + (this.initial_x + i * 30) + ' ' + (this.chevron_ypos) + ') scale(1 1) ';
                    });
                d3.select('svg').selectAll('#right_arrow').attr('fill', 'none');
            }

            //used to change text values at each position
            //if a string less than the length of the text elements is entered
            //text elements outside the length of the text will be blank
            updateText(text) {
                //change data to the text input
                //when write the ith char to the ith text element
                //lets update text elements
                //need to cancel any animations so call transition
                d3.select('svg').selectAll('.perm_text').transition();
                d3.select('svg').selectAll('.arrow').attr('fill', 'none');
                var svg = d3.select('svg');
                //max 4 letters
                for (i = 0; i < this.num_letters; i++) {
                    if (i >= text.length) {
                        svg.select('#lc' + i).select('#left_arrow').attr('fill', 'none');
                    } else {
                        svg.select('#lc' + i).select('#left_arrow').attr('fill', 'black');
                    }
                    svg.select('#t' + i).text(text.charAt(i));
                }
            }

            //we need to get this to disappear as we move away
            fadeOut() {
                //restore positions
                //
                d3.select("svg")
                    .selectAll(".perm_text")
                    .transition()
                    .duration(300)
                    .attr('font-size', '0px')
                    .attr('fill', 'white');
                //fade out direction arrows if they are visible
                d3.select("svg").selectAll(".arrow")
                    .transition().duration(300)
                    .attr('fill', 'none');
            }

            fadeIn() {
                var svg = d3.select('svg');
                svg.selectAll(".perm_text")
                    .transition()
                    .duration(300)
                    .attr('font-size', '32px')
                    .attr('fill','black');
                svg.selectAll("#left_arrow")
                    .transition().duration(300)
                    .attr('fill', 'black');
                
            }

            permute(action_list, index) {
                //take from array 2 at a time
                //i don't know what to do ?
                //console.log(array);
                //change the order of the data array then update the data
                //reset arrow positions
                //reset arrows
                //
                var obj = action_list[index];
                var key = Object.keys(obj)[0];
                console.log(obj);
                if (key == 'SWAP') {
                    //swap two elements
                    //swap 2 elements
                    console.log('swap');
                    //swap letters at position
                    var id_a = obj['SWAP'][0];
                    var id_b = obj['SWAP'][1];
                    var svg = d3.select('svg');

                    svg.select('#lc' + id_a).transition().delay(this.duration)
                        .attr('transform', 'translate(' + (this.initial_x + id_b * 30) + ',' + (this.chevron_ypos) + ') scale(1 1)');
                    svg.select('#lc' + id_b).transition().delay(this.duration)
                        .attr('transform', 'translate(' + (this.initial_x + id_a * 30) + ',' + (this.chevron_ypos) + ') scale(1 1)')
                        .on('end', () => {
                            svg.select('#lc' + id_b).attr('id', 'lc_temp');
                            svg.select('#lc' + id_a).attr('id', 'lc' + id_b);
                            svg.select('#lc_temp').attr('id', 'lc' + id_a);
                        });

                    svg.select('#t' + id_a).transition().delay(this.duration)
                        .attr('x', '' + (this.initial_x + id_b * 30));
                    svg.select('#t' + id_b).transition().delay(this.duration)
                        .attr('x', '' + (this.initial_x + id_a * 30)).on('end', () => {
                            svg.select('#t' + id_b).attr('id', 'jt_temp');
                            svg.select('#t' + id_a).attr('id', 't' + id_b);
                            svg.select('#jt_temp').attr('id', 't' + id_a);
                            if (index != action_list.length - 1) {
                                this.permute(action_list, index + 1);
                            }
                        });
                } else {
                    //flip direction
                    //flip the direction
                    console.log('flip');
                    var id = '#lc' + obj['NEW_DIRECTION'][0];
                    var new_direction = obj['NEW_DIRECTION'][1];
                    var svg = d3.select('svg');
                    if (new_direction == 1) {
                        //
                        svg.select(id).select('#left_arrow').transition().duration(this.duration)
                            .attr('fill', 'none');
                        svg.select(id).select('#right_arrow').transition().duration(this.duration)
                            .attr('fill', 'black').on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.permute(action_list, index + 1);
                                }
                            });

                    } else {
                        svg.select(id).select('#right_arrow').transition().duration(this.duration)
                            .attr('fill', 'none');
                        svg.select(id).select('#left_arrow').transition().duration(this.duration)
                            .attr('fill', 'black').on('end', () => {
                                if (index != action_list.length - 1) {
                                    this.permute(action_list, index + 1);
                                }
                            });
                    }

                }

            }

        }

        function clearCircles() {
            d3.selectAll("circle")
                .transition().duration(300)
                .attr('r', 0)
                .remove();
        }

        function updateSVGText(text) {
            //modify the data in the svg
            permString.updateText(text);
        } 
    </script>

    <title>Algo App</title>
</head>

<body>
    <!--Navbar-->
    <nav class="navbar navbar-expand-lg navbar-dark primary-color">

        <!-- Navbar brand -->
        <a class="navbar-brand" href="#">Algo App</a>

        <!-- Collapse button -->
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
            aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <!-- Collapsible content -->
        <div class="collapse navbar-collapse" id="basicExampleNav">
            <!-- Links -->
            <ul class="navbar-nav mr-auto">
                <!-- Dropdown -->
                <li class="nav-item active" id="quickhull">
                    <a href="#" class="nav-link active">QUICKHULL</a>
                </li>
                <li class="nav-item" id="johnson_trotter">
                    <a href="#" class="nav-link ">JOHNSON TROTTER</a>
                </li>
                <li class="nav-item" id="quicksort">
                    <a href="#" class="nav-link">QUICKSORT</a>
                </li>
            </ul>
            <!-- Links -->
        </div>
        <!-- Collapsible content -->

    </nav>
    <!--/.Navbar-->

    <div class="container-fluid h-100">
        <div class="row">
            <div class="col-lg-4 col-md-12">
                <!--
                    describe algorithm
                -->
                <div class="row">
                    <div class="col">
                        <div class="carousel slide" data-ride="false" data-interval="false">
                            <div class="carousel-inner">
                                <div class="carousel-item active">
                                    <h1>
                                        QUICKHULL
                                    </h1>
                                    <p>
                                        Convex Hull Problem
                                    </p>
                                    <p>
                                        Find the convex hull of a set of points on the cartesian plane.
                                    </p>
                                    <p>
                                        <b>Solution:</b>
                                    </p>
                                    <p>
                                        Given a set of points S ={p1, p2,.., pn} on the cartesian plane. Sort the set by
                                        increasing x coordinate, breaking ties using the larger y coordinate. The
                                        leftmost
                                        point, p1 and right most point pn of the set are part of the convex hull. The
                                        divide
                                        the
                                        set using the line p1pn into two smaller sets, one left of the line and one
                                        right of
                                        the
                                        line. The two sets are called the upper hull and the lower hull, the process
                                        must be
                                        repeated for each set, joining the sets will complete the convex hull.
                                    </p>
                                </div>
                                <div class="carousel-item">
                                    <h1>
                                        JOHNSON TROTTER
                                    </h1>
                                    <p>
                                        Permutation Generation Problem
                                    </p>
                                    <p>
                                        Generate all permutations of some string s.
                                    </p>
                                    <p>
                                        <b>Solution:</b>
                                    </p>
                                    <p>
                                        Given some string s. Each character in the s is a mobile element that has a
                                        value,
                                        the
                                        character, and
                                        a direction,default is left. An element is mobile if it points at an element
                                        smaller
                                        than itself. Swap the largest mobile element
                                        with the element that is in its direction. Every swap generates a permutation,
                                        continue
                                        this process until no mobile elements remain.
                                    </p>

                                    <div class="row">
                                        <div class="col-md-4 col-lg-8">
                                            <div class="md-form">
                                                <input maxLength="4" type="text" id="permutation_input"
                                                    class="form-control" pattern="([A-Za-z0-9])+">
                                                <label for="permutation_input">Permutations For:</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="carousel-item">
                                    <h1>
                                        QUICKSORT
                                    </h1>
                                    <p>
                                        Sorting an array of integers.
                                    </p>
                                    <p>
                                        Sort an array of integers in increasing order.
                                    </p>
                                    <p>
                                        <b>Solution:</b>
                                    </p>
                                    <p>
                                        Select a the element in the middle as the pivot. Use two iterators a left
                                        and
                                        right iterator.
                                        Left iterator starts at the beginning of the partition and the right iterator
                                        starts at the end of the partition.
                                        The left iterator will move over elements less than or equal to the pivot,
                                        when
                                        an element greater than the pivot is found
                                        swap the value at the left iterator and the pivot; right iterator moves
                                        over
                                        values greater than or equal to the pivot, when a value less than
                                        pivot is found
                                        swap with the pivot. This process continues until left and right iterators
                                        meet
                                        or run off the end. The pivot will now be in the correct location, and we
                                        must
                                        repeat
                                        this process for smaller paritions consisting of values left of the pivot
                                        and
                                        then values right of the pivot.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-8 col-md-12">
                {% block content %}
                {% endblock %}
            </div>
        </div>
    </div>
</body>

</html>